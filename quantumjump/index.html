<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Quantum Jump</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            margin: 0; padding: 0;
            -webkit-tap-highlight-color: transparent; /* Remove blue tap box on Android */
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at center, #0f0c29 0%, #302b63 50%, #24243e 100%);
            position: relative;
        }

        canvas {
            box-shadow: 0 0 80px rgba(0, 0, 0, 0.8);
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.02);
            backdrop-filter: blur(2px);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        /* --- UI Overlay --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 30px;
            z-index: 20;
        }

        .hud-panel {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .hud-box {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1.1rem;
            color: #e0e7ff;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
        }

        .hud-label {
            font-size: 0.7rem;
            color: #94a3b8;
            display: block;
            margin-bottom: 2px;
        }

        /* --- Pause Button --- */
        #pause-btn {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            width: 50px; height: 50px;
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 1.2rem; cursor: pointer;
            transition: all 0.2s;
        }
        #pause-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.3); }

        /* --- Touch Zones --- */
        .touch-zone {
            position: absolute; top: 0; bottom: 0; width: 50%; z-index: 10;
            transition: background 0.1s; /* Smooth flash effect */
        }
        #zone-left { left: 0; }
        #zone-right { right: 0; }
        
        /* Visual feedback class applied via JS */
        .touch-feedback {
            background: rgba(255, 255, 255, 0.05);
        }

        /* --- Menus --- */
        .modal {
            position: absolute; inset: 0;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 100;
            pointer-events: auto;
            transition: opacity 0.3s;
        }

        .btn-start {
            margin-top: 30px;
            background: linear-gradient(135deg, #4f46e5 0%, #818cf8 100%);
            border: none;
            color: white;
            padding: 15px 50px;
            font-size: 1.5rem;
            border-radius: 50px;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(79, 70, 229, 0.5);
            transition: transform 0.1s, box-shadow 0.1s;
            font-family: 'Orbitron', sans-serif;
        }
        .btn-start:active { transform: scale(0.95); box-shadow: 0 0 10px rgba(79, 70, 229, 0.5); }

        @keyframes pulse-text {
            0% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.8; transform: scale(1); }
        }
        .pulse-anim { animation: pulse-text 2s infinite; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="zone-left" class="touch-zone"></div>
    <div id="zone-right" class="touch-zone"></div>

    <div id="ui-layer">
        <div class="hud-panel">
            <div class="hud-box">
                <span class="hud-label">ENERGY</span>
                <span id="score">0</span>
            </div>
            <div class="hud-box">
                <span class="hud-label">VELOCITY</span>
                <span id="velocity-display">100%</span>
            </div>
        </div>
        
        <button id="pause-btn" onclick="togglePause()">❚❚</button>
    </div>

    <div id="start-modal" class="modal">
        <h1 class="text-6xl md:text-8xl font-bold text-transparent bg-clip-text bg-gradient-to-br from-cyan-300 to-indigo-500 mb-2 pulse-anim" style="filter: drop-shadow(0 0 15px rgba(34,211,238,0.5));">QUANTUM</h1>
        <h2 class="text-2xl text-gray-300 tracking-[0.5em] mb-8">ORBITAL RUNNER</h2>
        
        <div class="text-center text-gray-300 bg-gray-900/50 p-6 rounded-xl border border-gray-700/50 backdrop-blur-md max-w-lg">
            <p class="mb-4 text-lg">Dodge the <span class="text-red-400">Red Anomalies</span>.</p>
            <div class="grid grid-cols-2 gap-8 text-sm mb-4">
                <div class="border-r border-gray-600 pr-4">
                    <div class="text-2xl mb-1 text-cyan-400">TAP LEFT</div>
                    To Jump <b>IN</b><br>
                    (Smaller Ring)
                </div>
                <div class="pl-4">
                    <div class="text-2xl mb-1 text-cyan-400">TAP RIGHT</div>
                    To Jump <b>OUT</b><br>
                    (Larger Ring)
                </div>
            </div>
            <div class="text-xs text-indigo-300 border-t border-gray-700 pt-3">
                Keyboard: Arrow Keys to Move | Space to Pause
            </div>
        </div>

        <button class="btn-start" onclick="startGame()">START</button>
    </div>

    <div id="pause-modal" class="modal" style="display: none;">
        <h2 class="text-5xl text-white font-bold mb-6 tracking-widest">PAUSED</h2>
        <button class="btn-start" onclick="togglePause()">RESUME</button>
    </div>

    <div id="game-over-modal" class="modal" style="display: none;">
        <h2 class="text-5xl text-white font-bold mb-2">ORBIT DECAYED</h2>
        <p class="text-indigo-200 mb-6 text-xl">Distance Traveled: <span id="final-score" class="text-cyan-400 font-bold">0</span></p>
        <button class="btn-start" onclick="resetGame()">TRY AGAIN</button>
    </div>
</div>

<script>
    // --- Configuration ---
    const COLORS = {
        bg: '#000',
        nucleus: '#ffffff',
        electron: '#00ffff', 
        trail: 'rgba(0, 255, 255, 0.4)',
        hazard: '#ff2a2a',   
        shell: 'rgba(255, 255, 255, 0.15)', 
        activeShell: 'rgba(255, 255, 255, 0.5)',
        star: '#ffffff'
    };

    // --- State ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let isPlaying = false;
    let isPaused = false;
    let score = 0;
    
    let scaleFactor = 1; 
    let shellRadii = [60, 110, 160]; 
    
    let baseSpeed = 0.015; 
    let currentSpeed = baseSpeed;
    let maxSpeed = 0.06; 
    
    let player = {
        shellIndex: 0,
        angle: 0,
        visualRadius: 60,
        targetRadius: 60,
        trail: [] 
    };

    let hazards = [];
    let particles = [];
    let stars = [];
    let nebulaClouds = [];
    let animationId;

    // --- Audio ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);

        const now = audioCtx.currentTime;
        
        if (type === 'jump') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(300, now);
            osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'crash') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
            osc.start(now); osc.stop(now + 0.5);
        }
    }

    // --- Setup ---
    function resize() {
        const size = Math.min(window.innerWidth, window.innerHeight) * 0.95;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = size * dpr;
        canvas.height = size * dpr;
        canvas.style.width = size + 'px';
        canvas.style.height = size + 'px';
        
        ctx.setTransform(1, 0, 0, 1, 0, 0); 
        ctx.scale(dpr, dpr);
        ctx.translate(size/2, size/2);
        
        // --- RADIUS ADJUSTMENT HERE ---
        // Reduced from 0.9 to 0.75 for a tighter, smaller atom
        const maxRadius = (size / 2) * 0.75;
        
        const step = maxRadius / 3.5; 
        shellRadii = [step * 1.5, step * 2.5, step * 3.5];
        scaleFactor = size / 400; 

        player.targetRadius = shellRadii[player.shellIndex];
        if(!isPlaying) player.visualRadius = player.targetRadius;

        initBackground(size);
    }
    window.addEventListener('resize', resize);

    function initBackground(size) {
        stars = [];
        nebulaClouds = [];
        for(let i=0; i<100; i++) {
            stars.push({
                x: (Math.random() - 0.5) * size,
                y: (Math.random() - 0.5) * size,
                z: Math.random() * 2 + 0.5,
                size: Math.random() * 1.5,
                opacity: Math.random()
            });
        }
        for(let i=0; i<5; i++) {
            nebulaClouds.push({
                angle: Math.random() * Math.PI * 2,
                dist: Math.random() * (size/3),
                radius: Math.random() * 100 + 50,
                color: Math.random() > 0.5 ? 'rgba(79, 70, 229, 0.05)' : 'rgba(34, 211, 238, 0.05)',
                speed: (Math.random() - 0.5) * 0.002
            });
        }
    }

    // --- Controls ---
    function jump(direction) {
        if (!isPlaying || isPaused) return;
        
        let moved = false;
        if (direction === 'in' && player.shellIndex > 0) {
            player.shellIndex--;
            moved = true;
        } else if (direction === 'out' && player.shellIndex < shellRadii.length - 1) {
            player.shellIndex++;
            moved = true;
        }

        if (moved) {
            player.targetRadius = shellRadii[player.shellIndex];
            playSound('jump');
            createParticles(player.angle, player.visualRadius, COLORS.electron, 5);
        }
    }

    // Input Listeners
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') togglePause();
        if (e.key === 'ArrowLeft') jump('in');
        if (e.key === 'ArrowRight') jump('out');
    });

    // Mobile Touch Handlers with Visual Feedback
    const zoneLeft = document.getElementById('zone-left');
    const zoneRight = document.getElementById('zone-right');

    function flashZone(zone) {
        zone.classList.add('touch-feedback');
        setTimeout(() => zone.classList.remove('touch-feedback'), 100);
    }

    zoneLeft.addEventListener('touchstart', (e) => { 
        e.preventDefault(); 
        jump('in'); 
        flashZone(zoneLeft);
    });
    
    zoneRight.addEventListener('touchstart', (e) => { 
        e.preventDefault(); 
        jump('out'); 
        flashZone(zoneRight);
    });

    function togglePause() {
        if (!isPlaying) return;
        isPaused = !isPaused;
        
        const modal = document.getElementById('pause-modal');
        const btn = document.getElementById('pause-btn');
        
        if (isPaused) {
            modal.style.display = 'flex';
            btn.innerText = "▶";
            cancelAnimationFrame(animationId);
        } else {
            modal.style.display = 'none';
            btn.innerText = "❚❚";
            loop();
        }
    }

    // --- Game Logic ---

    function spawnHazard() {
        const shellIdx = Math.floor(Math.random() * 3);
        const spawnAngle = player.angle + Math.PI + (Math.random() * 0.5); 
        hazards.push({
            shellIndex: shellIdx,
            angle: spawnAngle,
            radius: shellRadii[shellIdx],
            rotation: Math.random() * Math.PI,
            active: true
        });
    }

    function update() {
        if (!isPlaying || isPaused) return;

        currentSpeed = Math.min(maxSpeed, baseSpeed + (score * 0.000005));
        
        if (Math.random() < (0.02 + (score * 0.00001))) {
            const lastHazard = hazards[hazards.length - 1];
            if (!lastHazard || (lastHazard.angle < player.angle + Math.PI - 0.5)) {
                spawnHazard();
            }
        }

        player.angle += currentSpeed;
        player.visualRadius += (player.targetRadius - player.visualRadius) * 0.2;

        player.trail.push({ angle: player.angle, radius: player.visualRadius, alpha: 1.0 });
        if (player.trail.length > 15) player.trail.shift();
        player.trail.forEach(t => t.alpha -= 0.08);

        score++;
        document.getElementById('score').innerText = Math.floor(score / 10);
        
        const velPercent = Math.floor((currentSpeed / baseSpeed) * 100);
        document.getElementById('velocity-display').innerText = velPercent + "%";

        hazards = hazards.filter(h => h.angle > player.angle - (Math.PI * 1.5));
        
        const px = Math.cos(player.angle) * player.visualRadius;
        const py = Math.sin(player.angle) * player.visualRadius;

        hazards.forEach(h => {
            h.rotation += 0.05;
            h.radius = shellRadii[h.shellIndex];
            const hx = Math.cos(h.angle) * h.radius;
            const hy = Math.sin(h.angle) * h.radius;
            const dist = Math.sqrt( (px-hx)**2 + (py-hy)**2 );
            
            if (dist < 15 * scaleFactor) gameOver();
        });

        particles.forEach((p, i) => {
            p.life -= 0.05;
            p.x += p.vx;
            p.y += p.vy;
            if(p.life <= 0) particles.splice(i, 1);
        });
    }

    function draw() {
        ctx.clearRect(-canvas.width, -canvas.height, canvas.width*2, canvas.height*2);

        // Nebula & Stars
        nebulaClouds.forEach(cloud => {
            cloud.angle += cloud.speed;
            const x = Math.cos(cloud.angle) * cloud.dist;
            const y = Math.sin(cloud.angle) * cloud.dist;
            const grad = ctx.createRadialGradient(x, y, 0, x, y, cloud.radius);
            grad.addColorStop(0, cloud.color); grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(x, y, cloud.radius, 0, Math.PI*2); ctx.fill();
        });

        stars.forEach(star => {
            const rot = -player.angle * (0.1 / star.z); 
            const x = star.x * Math.cos(rot) - star.y * Math.sin(rot);
            const y = star.x * Math.sin(rot) + star.y * Math.cos(rot);
            ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
            ctx.beginPath(); ctx.arc(x, y, star.size, 0, Math.PI*2); ctx.fill();
        });

        // Shells
        shellRadii.forEach((r, i) => {
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.strokeStyle = COLORS.shell;
            ctx.lineWidth = 1 * scaleFactor;
            if (i === player.shellIndex) {
                ctx.strokeStyle = COLORS.activeShell;
                ctx.lineWidth = 2 * scaleFactor;
                ctx.shadowColor = '#4f46e5'; ctx.shadowBlur = 10 * scaleFactor;
            } else { ctx.shadowBlur = 0; }
            ctx.stroke();
        });
        ctx.shadowBlur = 0;

        // Nucleus
        ctx.shadowBlur = 30 * scaleFactor; ctx.shadowColor = '#ffffff';
        ctx.fillStyle = COLORS.nucleus;
        ctx.beginPath(); ctx.arc(0, 0, 12 * scaleFactor, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;

        // Hazards
        hazards.forEach(h => {
            const hx = Math.cos(h.angle) * h.radius;
            const hy = Math.sin(h.angle) * h.radius;
            ctx.save(); ctx.translate(hx, hy); ctx.rotate(h.rotation);
            ctx.shadowBlur = 15 * scaleFactor; ctx.shadowColor = COLORS.hazard; ctx.fillStyle = COLORS.hazard;
            ctx.beginPath();
            for(let i=0; i<5; i++) {
                ctx.lineTo(Math.cos((18+i*72)/180*Math.PI)*(10 * scaleFactor), Math.sin((18+i*72)/180*Math.PI)*(10 * scaleFactor));
                ctx.lineTo(Math.cos((54+i*72)/180*Math.PI)*(5 * scaleFactor), Math.sin((54+i*72)/180*Math.PI)*(5 * scaleFactor));
            }
            ctx.closePath(); ctx.fill(); ctx.restore();
        });
        ctx.shadowBlur = 0;

        // Player
        if (player.trail.length > 1) {
            ctx.beginPath();
            const p0 = player.trail[0];
            ctx.moveTo(Math.cos(p0.angle)*p0.radius, Math.sin(p0.angle)*p0.radius);
            for (let i = 1; i < player.trail.length; i++) {
                const p = player.trail[i];
                ctx.lineTo(Math.cos(p.angle)*p.radius, Math.sin(p.angle)*p.radius);
            }
            ctx.lineCap = 'round'; ctx.lineWidth = 4 * scaleFactor;
            ctx.strokeStyle = COLORS.trail; ctx.shadowBlur = 20 * scaleFactor; ctx.shadowColor = COLORS.electron;
            ctx.stroke();
        }

        const px = Math.cos(player.angle) * player.visualRadius;
        const py = Math.sin(player.angle) * player.visualRadius;
        
        ctx.shadowBlur = 20 * scaleFactor; ctx.shadowColor = COLORS.electron;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath(); ctx.arc(px, py, 6 * scaleFactor, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;

        particles.forEach(p => {
            ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size * scaleFactor, 0, Math.PI*2); ctx.fill();
        });
        ctx.globalAlpha = 1;
    }

    function createParticles(angle, radius, color, count) {
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        for(let i=0; i<count; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 4 * scaleFactor,
                vy: (Math.random() - 0.5) * 4 * scaleFactor,
                life: 1.0, color: color, size: Math.random() * 2 + 1
            });
        }
    }

    function gameOver() {
        isPlaying = false;
        playSound('crash');
        createParticles(player.angle, player.visualRadius, '#ff0000', 30);
        document.getElementById('final-score').innerText = Math.floor(score / 10);
        document.getElementById('game-over-modal').style.display = 'flex';
        cancelAnimationFrame(animationId);
    }

    function loop() {
        if (isPaused) return;
        update();
        draw();
        animationId = requestAnimationFrame(loop);
    }

    function startGame() {
        document.getElementById('start-modal').style.display = 'none';
        resetLogic();
        isPlaying = true;
        loop();
    }

    function resetGame() {
        document.getElementById('game-over-modal').style.display = 'none';
        resetLogic();
        isPlaying = true;
        loop();
    }

    function resetLogic() {
        score = 0;
        currentSpeed = baseSpeed;
        player.shellIndex = 0;
        player.angle = 0;
        player.trail = [];
        hazards = [];
        particles = [];
        resize(); // Recalculate radii
    }

    resize();
    initBackground(Math.min(window.innerWidth, window.innerHeight));
    // Initial draw to show background before start
    draw();

</script>

</body>
</html>